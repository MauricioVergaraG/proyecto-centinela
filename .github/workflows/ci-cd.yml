name: CI/CD Full - Centinela (DevSecOps)

on:
  push:
    branches: [ main ]
  pull_request:
    branches: [ main ]
  workflow_dispatch: {}

jobs:

  setup-cache:
    name: Prepare & Cache (pip / npm)
    runs-on: ubuntu-latest
    steps:
      - name: Checkout
        uses: actions/checkout@v4
      - name: Cache pip packages
        id: cache-pip
        uses: actions/cache@v4
        with:
          path: ~/.cache/pip
          key: pip-${{ hashFiles('**/services/**/requirements.txt') }}-${{ runner.os }}
          restore-keys: |
            pip-${{ runner.os }}
      - name: Cache node modules
        id: cache-node
        uses: actions/cache@v4
        with:
          path: |
            services/frontend/node_modules
            ~/.npm
          key: node-${{ hashFiles('services/frontend/**/package-lock.json') }}-${{ runner.os }}
          restore-keys: |
            node-${{ runner.os }}

  lint-format-sast:
    name: Lint / Format / SAST
    runs-on: ubuntu-latest
    needs: setup-cache
    steps:
      - uses: actions/checkout@v4
      - uses: actions/setup-python@v4
        with:
          python-version: '3.11'
      - run: |
          python -m pip install --upgrade pip
          pip install black flake8 bandit semgrep
      - run: black --check services
      - run: flake8 services
      - run: bandit -r services/api -lll
      - run: semgrep --config ./.semgrep/basic-rules.yml

  dependency-scan:
    name: Dependency & Filesystem Scan (Trivy SBOM)
    runs-on: ubuntu-latest
    needs: lint-format-sast
    steps:
      - uses: actions/checkout@v4
      - run: curl -sfL https://raw.githubusercontent.com/aquasecurity/trivy/main/contrib/install.sh | sh -s -- -b /usr/local/bin
      - run: trivy fs --severity HIGH,CRITICAL --exit-code 1 --no-progress .

  tests:
    name: Unit & Smoke Tests
    runs-on: ubuntu-latest
    needs: dependency-scan
    steps:
      - uses: actions/checkout@v4
      - uses: actions/setup-python@v4
        with:
          python-version: '3.11'
      - run: |
          echo "PYTHONPATH=$PYTHONPATH:$(pwd)" >> $GITHUB_ENV
      - run: |
          pip install -r services/api/requirements.txt
          pip install pytest
          pytest -q
      - uses: actions/setup-node@v4
        with:
          node-version: '20'
      - run: |
          cd services/frontend
          npm install
          npm run build --if-present

  build-and-scan-images:
    name: Build, Scan & Push Versioned Images
    runs-on: ubuntu-latest
    needs: tests
    env:
      REGISTRY: ghcr.io
      IMAGE_NAMESPACE: ${{ github.repository }} # No se toca, esto funciona.
      GHCR_TOKEN: ${{ secrets.GHCR_TOKEN }}
    steps:
      - uses: actions/checkout@v4

      - name: Login to GHCR
        if: ${{ env.GHCR_TOKEN != '' }}
        uses: docker/login-action@v3
        with:
          registry: ${{ env.REGISTRY }}
          username: ${{ github.actor }}
          password: ${{ env.GHCR_TOKEN }}

      - name: Build, scan and push images
        run: |
          IMAGE_NS=$(echo "${IMAGE_NAMESPACE}" | tr '[:upper:]' '[:lower:]')

          API_IMG_ID="$REGISTRY/$IMAGE_NS/api:${{ github.run_id }}"
          FRONTEND_IMG_ID="$REGISTRY/$IMAGE_NS/frontend:${{ github.run_id }}"
          SCRAPER_IMG_ID="$REGISTRY/$IMAGE_NS/scraper:${{ github.run_id }}"

          docker build -t $API_IMG_ID -f services/api/Dockerfile services/api
          docker build -t $FRONTEND_IMG_ID -f services/frontend/Dockerfile services/frontend
          docker build -t $SCRAPER_IMG_ID -f services/scraper/Dockerfile services/scraper

          curl -sfL https://raw.githubusercontent.com/aquasecurity/trivy/main/contrib/install.sh | sh -s -- -b /usr/local/bin

          mkdir -p reports
          trivy --download-db-only || true

          # --- ¡AHORA FALLARÁ SI ENCUENTRA CVEs! ---
          trivy image --format json --output reports/trivy-api.json --severity HIGH,CRITICAL --exit-code 1 $API_IMG_ID
          trivy image --format json --output reports/trivy-frontend.json --severity HIGH,CRITICAL --exit-code 1 $FRONTEND_IMG_ID
          trivy image --format json --output reports/trivy-scraper.json --severity HIGH,CRITICAL --exit-code 1 $SCRAPER_IMG_ID

          # También generamos reportes HTML legibles usando la plantilla incluida
          # en Trivy (si está disponible). No deberían impedir el exit code.
          trivy image --format template --template @contrib/html.tpl --output reports/trivy-api.html $API_IMG_ID || true
          trivy image --format template --template @contrib/html.tpl --output reports/trivy-frontend.html $FRONTEND_IMG_ID || true
          trivy image --format template --template @contrib/html.tpl --output reports/trivy-scraper.html $SCRAPER_IMG_ID || true

          # Empaquetar todos los reportes en un ZIP para facilitar descarga
          cd reports && zip -r ../trivy-reports-${{ github.run_id }}.zip . || true
          cd - >/dev/null || true

          docker push $API_IMG_ID
          docker push $FRONTEND_IMG_ID
          docker push $SCRAPER_IMG_ID

      # --- ¡CORRECCIÓN! Reportes de Trivy se suben AHORA ---
      - name: Upload Trivy reports
        if: always() # Subir reportes incluso si el 'step' anterior falló
        uses: actions/upload-artifact@v4
        with:
          name: trivy-reports
          path: |
            reports/*.json
            reports/*.html
            trivy-reports-*.zip
          if-no-files-found: ignore

  dast:
    name: DAST — OWASP ZAP
    runs-on: ubuntu-latest
    needs: build-and-scan-images
    permissions:
      contents: read
      issues: write
      pull-requests: write
      actions: read
    outputs:
      dast_critical: ${{ steps.set-dast-output.outputs.dast_critical }}
      dast_high: ${{ steps.set-dast-output.outputs.dast_high }}
      dast_total: ${{ steps.set-dast-output.outputs.dast_total }}
    # --- ¡IMPORTANTE! Añadido if:always() ---
    # Esto asegura que DAST corra incluso si el job de build
    # falla (ej. por un fallo de Trivy que SÍ queremos ver)
    if: always()
    env:
      REGISTRY: ghcr.io
      IMAGE_NAMESPACE: ${{ github.repository }}
      IMAGE_TAG: ${{ github.run_id }}
      GHCR_TOKEN: ${{ secrets.GHCR_TOKEN }}
    steps:
      - uses: actions/checkout@v4

      - name: Login to GHCR
        if: ${{ env.GHCR_TOKEN != '' }}
        uses: docker/login-action@v3
        with:
          registry: ${{ env.REGISTRY }}
          username: ${{ github.actor }}
          password: ${{ env.GHCR_TOKEN }}

      - name: Run application stack
        run: |
          export IMAGE_NAMESPACE=$(echo "${{ env.IMAGE_NAMESPACE }}" | tr '[:upper:]' '[:lower:]')
          export IMAGE_TAG=${{ env.IMAGE_TAG }}

          # Primero construimos explícitamente las imágenes necesarias en el
          # runner para evitar errores de 'manifest unknown' cuando no están
          # publicadas en el registry.
          echo "Building service images (frontend, api, scraper)"
          DOCKER_BUILDKIT=1 docker compose -f docker-compose.yml build frontend api scraper --no-cache 2>&1 | tee build-compose.log || BUILD_FAILED=1

          if [ ! -z "${BUILD_FAILED}" ]; then
            echo "ERROR: docker compose build failed. Dumping build log to reports/build-compose.log"
            mkdir -p reports || true
            cp build-compose.log reports/ || true
            exit 1
          fi

          # Intentar 'pull' (si las imágenes existen en el registry). No fallar si no están.
          docker compose -f docker-compose.yml pull || true

          # Levanta el stack usando las imágenes ya construidas
          docker compose -f docker-compose.yml up -d && sleep 30

      - name: Run ZAP Baseline Scan
        # Ejecutar ZAP y dejar que el step falle si hay problemas (bloqueante)
        run: |
          mkdir -p reports

          FRONTEND_CID=$(docker compose ps -q frontend)
          if [ -z "$FRONTEND_CID" ]; then
            echo "ERROR: no se encontró el contenedor 'frontend'"
            docker compose ps || true
            exit 1
          fi

          NETWORK_NAME=$(docker inspect --format '{{range $k,$v := .NetworkSettings.Networks}}{{$k}} {{end}}' $FRONTEND_CID | awk '{print $1}')
          echo "Conectando ZAP a la red: $NETWORK_NAME"

          echo "Esperando a que frontend responda en http://frontend:80..."
          REACHABLE=0
          for i in $(seq 1 12); do
            echo "Intento $i/12..."
            docker run --rm --network "$NETWORK_NAME" busybox wget -qO- http://frontend:80 >/dev/null 2>&1 && { REACHABLE=1; echo "frontend responde dentro de la red"; break; } || sleep 5
          done

          if [ "$REACHABLE" -ne 1 ]; then
            echo "WARNING: frontend no responde..."
            docker logs $FRONTEND_CID || true
          fi

          # Ejecutar contenedor ZAP como root para evitar problemas de permisos
          # Ejecutar ZAP dentro del contenedor con el directorio de trabajo
          # puesto a /zap/wrk y pasar el nombre de archivo relativo a -r.
          # Capturamos el código de salida de ZAP y lo guardamos en reports/
          # para que el step no haga fallar el job inmediatamente (permitimos
          # continuar para subir reportes y parsearlos en pasos posteriores).
          # Esto evita que ZAP haga 'exit 2' y detenga el workflow antes de
          # subir los artefactos.
          docker run --rm \
            -u 0 \
            --network "$NETWORK_NAME" \
            --name zap_scanner \
            -v "$(pwd)/reports":/zap/wrk \
            -w /zap/wrk \
            ghcr.io/zaproxy/zaproxy zap-baseline.py \
              -t http://frontend:80 \
              -r report_dast_zap.html \
              -J report_dast_zap.json || true

          # Guardar el código de salida (si hubo) para diagnóstico posterior
          ZAP_EXIT=${ZAP_EXIT:-$?}
          mkdir -p reports || true
          echo "$ZAP_EXIT" > reports/zap_exit_code.txt || true
          echo "ZAP exit code: $ZAP_EXIT"
          # NOTA: el paso continúa siempre; la decisión de crear un issue o
          # fallar el pipeline se realiza al parsear el JSON y contar
          # HIGH/CRITICAL en pasos posteriores.

      - name: Ensure ZAP report
        if: always()
        run: |
          echo "Listado de carpeta 'reports':"
          ls -la reports || true
          if [ -f reports/report_dast_zap.html ]; then
            echo "ZAP report encontrado: reports/report_dast_zap.html"
          else
            echo "ZAP report no encontrado"
          fi

      - name: Upload ZAP report
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: reporte-dast-zap
          path: reports/report_dast_zap.html
          if-no-files-found: ignore

      - name: Upload ZAP JSON report
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: reporte-dast-zap-json
          path: reports/report_dast_zap.json
          if-no-files-found: ignore

      - name: Collect frontend headers (debug)
        if: always()
        run: |
          mkdir -p reports || true
          FRONTEND_CID=$(docker compose ps -q frontend)
          if [ -z "$FRONTEND_CID" ]; then
            echo "WARNING: frontend container missing for headers collection"
          else
            NETWORK_NAME=$(docker inspect --format '{{range $k,$v := .NetworkSettings.Networks}}{{$k}} {{end}}' $FRONTEND_CID | awk '{print $1}')
            docker run --rm --network "$NETWORK_NAME" curlimages/curl:8.5.0 -sI http://frontend:80 > reports/frontend-headers.txt || true
          fi

      - name: Upload frontend headers (debug)
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: frontend-headers
          path: reports/frontend-headers.txt
          if-no-files-found: ignore

      - name: Parse ZAP JSON & set outputs
        id: set-dast-output
        if: always()
        run: |
          set -euo pipefail || true
          mkdir -p reports || true
          if [ ! -f reports/report_dast_zap.json ]; then
            echo "dast_critical=0" >> $GITHUB_OUTPUT
            echo "dast_high=0" >> $GITHUB_OUTPUT
            echo "dast_total=0" >> $GITHUB_OUTPUT
            exit 0
          fi

          # ensure jq is available
          if ! command -v jq >/dev/null 2>&1; then
            sudo apt-get update -y && sudo apt-get install -y jq || true
          fi

          # Count alerts by risk level
          total=$(jq '[.site[]?.alerts[]?] | length' reports/report_dast_zap.json || echo 0)
          critical=$(jq '[.site[]?.alerts[]? | select(.risk=="High" or .risk=="Critical")] | length' reports/report_dast_zap.json || echo 0)
          high=$(jq '[.site[]?.alerts[]? | select(.risk=="High")] | length' reports/report_dast_zap.json || echo 0)
          medium=$(jq '[.site[]?.alerts[]? | select(.risk=="Medium")] | length' reports/report_dast_zap.json || echo 0)
          low=$(jq '[.site[]?.alerts[]? | select(.risk=="Low")] | length' reports/report_dast_zap.json || echo 0)

          echo "dast_critical=$critical" >> $GITHUB_OUTPUT
          echo "dast_high=$high" >> $GITHUB_OUTPUT
          echo "dast_total=$total" >> $GITHUB_OUTPUT
          echo "Parsed DAST counts: total=$total critical=$critical high=$high medium=$medium low=$low"

      - name: Create issue or comment if HIGH/CRITICAL findings
        if: always()
        uses: actions/github-script@v6
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const fs = require('fs');
            const path = './reports/report_dast_zap.json';
            const critical = parseInt(process.env.DAST_CRITICAL || '0');
            const high = parseInt(process.env.DAST_HIGH || '0');
            const total = parseInt(process.env.DAST_TOTAL || '0');
            const runUrl = `https://github.com/${process.env.GITHUB_REPOSITORY}/actions/runs/${process.env.GITHUB_RUN_ID}`;

            let topAlertsSection = '';
            try {
              if (fs.existsSync(path)) {
                const raw = fs.readFileSync(path, 'utf8');
                const json = JSON.parse(raw);
                const alerts = (json.site || []).flatMap(s => s.alerts || []);
                if (alerts.length > 0) {
                  // Build a top-5 list with name, risk and a sample URI
                  const top = alerts.slice(0, 5).map(a => {
                    const name = a.name || a.alert || 'Unknown alert';
                    const risk = a.risk || a.riskcode || 'Unknown';
                    let uri = 'n/a';
                    if (Array.isArray(a.instances) && a.instances.length > 0) {
                      uri = a.instances[0].uri || a.instances[0].evidence || 'n/a';
                    } else if (a.uri) {
                      uri = a.uri;
                    }
                    return `- **${name}** (_${risk}_) — ${uri}`;
                  }).join('\n');
                  topAlertsSection = `\nTop alerts (first 5):\n${top}\n`;
                }
              }
            } catch (e) {
              core.warning('Failed to read/parse ZAP JSON for top alerts: ' + e.message);
            }

            if (critical > 0 || high > 0) {
              const body = `DAST scan detected issues:\n- total alerts: ${total}\n- critical: ${critical}\n- high: ${high}\n${topAlertsSection}\nPlease review the DAST report artifacts attached to this workflow run: ${runUrl}\n`;
              if (github.context.payload && github.context.payload.pull_request) {
                await github.rest.issues.createComment({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  issue_number: github.context.payload.pull_request.number,
                  body
                });
              } else {
                await github.rest.issues.create({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  title: `DAST findings: ${critical} critical / ${high} high (run #${process.env.GITHUB_RUN_ID})`,
                  body
                });
              }
            } else {
              core.info('No HIGH/CRITICAL DAST findings — no issue/comment created');
            }
        env:
          DAST_CRITICAL: ${{ steps.set-dast-output.outputs.dast_critical }}
          DAST_HIGH: ${{ steps.set-dast-output.outputs.dast_high }}
          DAST_TOTAL: ${{ steps.set-dast-output.outputs.dast_total }}

      - name: Fail job if critical/high findings
        if: always() # Asegurarse de que corra
        run: |
          CRITICAL=${{ steps.set-dast-output.outputs.dast_critical }}
          HIGH=${{ steps.set-dast-output.outputs.dast_high }}

          echo "Findings: $CRITICAL critical, $HIGH high"
          if [ "$CRITICAL" -gt 0 ] || [ "$HIGH" -gt 0 ]; then
            echo "::error:: DAST found $CRITICAL critical and $HIGH high vulnerabilities. Failing build."
            exit 1
          else
            echo "DAST scan passed."
          fi

      - name: Stop application stack
        if: always()
        run: docker compose -f docker-compose.yml down --volumes --remove-orphans

  publish-and-deploy:
    name: Publish ':latest' tags
    runs-on: ubuntu-latest
    needs: dast
    permissions:
      contents: read
      packages: write
    env:
      REGISTRY: ghcr.io
      IMAGE_NAMESPACE: ${{ github.repository }} # No se toca, esto funciona.
      GHCR_TOKEN: ${{ secrets.GHCR_TOKEN }}
    steps:
      - name: Login GHCR
        if: ${{ env.GHCR_TOKEN != '' }}
        uses: docker/login-action@v3
        with:
          registry: ${{ env.REGISTRY }}
          username: ${{ github.actor }}
          password: ${{ env.GHCR_TOKEN }}

      - run: |
          IMAGE_NS=$(echo "${IMAGE_NAMESPACE}" | tr '[:upper:]' '[:lower:]')
          # --- ¡CORRECCIÓN DE NOMBRES! ---
          docker pull $REGISTRY/$IMAGE_NS/api:${{ github.run_id }}
          docker tag  $REGISTRY/$IMAGE_NS/api:${{ github.run_id }} $REGISTRY/$IMAGE_NS/api:latest
          docker push $REGISTRY/$IMAGE_NS/api:latest
      - run: |
          IMAGE_NS=$(echo "${IMAGE_NAMESPACE}" | tr '[:upper:]' '[:lower:]')
          # --- ¡CORRECCIÓN DE NOMBRES! ---
          docker pull $REGISTRY/$IMAGE_NS/frontend:${{ github.run_id }}
          docker tag  $REGISTRY/$IMAGE_NS/frontend:${{ github.run_id }} $REGISTRY/$IMAGE_NS/frontend:latest
          docker push $REGISTRY/$IMAGE_NS/frontend:latest
      - run: |
          IMAGE_NS=$(echo "${IMAGE_NAMESPACE}" | tr '[:upper:]' '[:lower:]')
          # --- ¡CORRECCIÓN DE NOMBRES! ---
          docker pull $REGISTRY/$IMAGE_NS/scraper:${{ github.run_id }}
          docker tag  $REGISTRY/$IMAGE_NS/scraper:${{ github.run_id }} $REGISTRY/$IMAGE_NS/scraper:latest
          docker push $REGISTRY/$IMAGE_NS/scraper:latest

  cleanup:
    name: Cleanup
    runs-on: ubuntu-latest
    needs: publish-and-deploy
    if: always()
    steps:
      - run: docker image prune -af || true

      # --- ¡ESTE ES EL NUEVO JOB! ---
  deploy-to-production:
    name: "Deploy to Production"
    runs-on: ubuntu-latest

    # Solo se ejecuta si el job 'publish-and-deploy' tuvo éxito
    needs: publish-and-deploy
    if: github.event_name == 'push' && github.ref == 'refs/heads/main'

    permissions:
      contents: read
      packages: write
    env:
      REGISTRY: ghcr.io

    steps:
      - name: 1. Checkout (para obtener el docker-compose.yml)
        uses: actions/checkout@v4

      - name: 2. Configurar clave SSH
        # Esta acción instala la clave SSH en el runner
        uses: shimataro/ssh-key-action@v2
        with:
          key: ${{ secrets.DEPLOY_KEY }}
          known_hosts: 'placeholder' # Necesario, pero lo sobreescribimos

      - name: 3. Añadir IP del host a known_hosts
        # Esto previene el "pop-up" de "confías en este host?"
        run: |
          ssh-keyscan -H ${{ secrets.DEPLOY_HOST }} >> ~/.ssh/known_hosts

      - name: 4. Desplegar en el Servidor
        run: |
          # 1. Definir el usuario y host
          REMOTE_HOST="${{ secrets.DEPLOY_USER }}@${{ secrets.DEPLOY_HOST }}"

          # 2. (¡Importante!) Copiar el docker-compose.yml al servidor
          #    Esto asegura que el servidor tenga la última versión del compose
          scp -o StrictHostKeyChecking=no docker-compose.yml $REMOTE_HOST:/home/ubuntu/centinela/docker-compose.yml

          # 3. Conectarse por SSH y ejecutar los comandos de despliegue
          ssh -o StrictHostKeyChecking=no $REMOTE_HOST << 'EOF'

            # Navegar a la carpeta del proyecto en el servidor
            cd /home/ubuntu/centinela

            # ¡Importante! Iniciar sesión en GHCR (el registro)
            # El servidor necesita permiso para jalar tus imágenes privadas
            echo "${{ secrets.GHCR_TOKEN }}" | docker login ghcr.io -u ${{ github.actor }} --password-stdin

            # Jalar (pull) las nuevas imágenes :latest
            docker compose pull

            # Reiniciar la aplicación con las nuevas imágenes
            docker compose up -d

            # Limpiar imágenes antiguas
            docker image prune -af
