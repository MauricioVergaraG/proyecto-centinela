# ------------------------------------------------------------------
# Nombre del Workflow
# ------------------------------------------------------------------
name: CI/CD Full - Centinela (DevSecOps Optimized)

# ------------------------------------------------------------------
# Disparadores (Triggers)
# ------------------------------------------------------------------
on:
  push:
    branches: [ main, feature/* ] # ¡Agregamos feature/* para que pruebes tu rama!
  pull_request:
    branches: [ main ]
  workflow_dispatch: {}

# ------------------------------------------------------------------
# Trabajos (Jobs)
# ------------------------------------------------------------------
jobs:

  # ------------------------------------------------------------------
  # Job 1: Preparar Caché (Base para todos)
  # ------------------------------------------------------------------
  setup-cache:
    name: Prepare & Cache
    runs-on: ubuntu-latest
    steps:
      - name: Checkout
        uses: actions/checkout@v4
      - name: Cache pip packages
        uses: actions/cache@v4
        with:
          path: ~/.cache/pip
          key: pip-${{ hashFiles('**/services/**/requirements.txt') }}-${{ runner.os }}
          restore-keys: |
            pip-${{ runner.os }}
      - name: Cache node modules
        uses: actions/cache@v4
        with:
          path: |
            services/frontend/node_modules
            ~/.npm
          key: node-${{ hashFiles('services/frontend/**/package-lock.json') }}-${{ runner.os }}
          restore-keys: |
            node-${{ runner.os }}
      # MEJORA: Caché compartido para la DB de Trivy
      - name: Cache Trivy DB
        uses: actions/cache@v4
        with:
          path: .trivy
          key: trivy-db-${{ runner.os }}-${{ github.run_id }} # Key única para escritura
          restore-keys: |
            trivy-db-${{ runner.os }}

  # ------------------------------------------------------------------
  # Job 2: Escaneo Estático (SAST)
  # MEJORA: Ahora corre en paralelo (depende solo de setup-cache)
  # ------------------------------------------------------------------
  lint-format-sast:
    name: Lint / Format / SAST
    runs-on: ubuntu-latest
    needs: setup-cache # Paralelismo activado
    steps:
      - uses: actions/checkout@v4
      - uses: actions/setup-python@v4
        with:
          python-version: '3.11'
      - run: |
          python -m pip install --upgrade pip
          pip install black flake8 bandit semgrep
      - run: black --check services
      - run: flake8 services --ignore=E501,W503,W291
      - run: bandit -r services/api -lll
      - run: semgrep --config ./.semgrep/basic-rules.yml

  # ------------------------------------------------------------------
  # Job 3: Escaneo de Dependencias (SCA)
  # MEJORA: Ahora corre en paralelo (depende solo de setup-cache)
  # ------------------------------------------------------------------
  dependency-scan:
    name: Dependency Scan (Trivy Filesystem)
    runs-on: ubuntu-latest
    needs: setup-cache # Paralelismo activado
    steps:
      - uses: actions/checkout@v4
      - run: curl -sfL https://raw.githubusercontent.com/aquasecurity/trivy/main/contrib/install.sh | sh -s -- -b /usr/local/bin
      
      # Usamos el caché de Trivy preparado en Job 1 si es posible
      - run: trivy fs --cache-dir .trivy --severity HIGH,CRITICAL --exit-code 1 --no-progress .

  # ------------------------------------------------------------------
  # Job 4: Escaneo de Infraestructura (IaC)
  # MEJORA: Ahora corre en paralelo (depende solo de setup-cache)
  # ------------------------------------------------------------------
  iac-scan:
    name: IaC Scan (Checkov)
    runs-on: ubuntu-latest
    needs: setup-cache # Paralelismo activado
    steps:
        - name: Checkout
          uses: actions/checkout@v4
        - name: Run Checkov scan
          uses: bridgecrewio/checkov-action@v12
          with:
            directory: ./terraform
            framework: terraform
            output_format: cli
            soft_fail: true 

  # ------------------------------------------------------------------
  # Job 5: Pruebas Unitarias
  # Depende de que los escaneos anteriores pasen para no gastar cómputo en código inseguro
  # ------------------------------------------------------------------
  tests:
    name: Unit & Smoke Tests
    runs-on: ubuntu-latest
    # Esperamos a que terminen los chequeos de seguridad paralelos
    needs: [lint-format-sast, dependency-scan, iac-scan]
    steps:
      - uses: actions/checkout@v4
      - uses: actions/setup-python@v4
        with:
          python-version: '3.11'
      - name: Instalar y Correr Pruebas de Python
        env:
          PYTHONPATH: ${{ github.workspace }}
        run: |
          pip install -r services/api/requirements.txt
          pip install pytest
          pytest -q services/api/tests/
      - uses: actions/setup-node@v4
        with:
          node-version: '20'
      - name: Construir Frontend (smoke test)
        run: |
          cd services/frontend
          if [ -f "index.html" ]; then echo "index.html encontrado."; else exit 1; fi

  # ------------------------------------------------------------------
  # Job 6: Construcción y Escaneo de Imágenes Docker
  # ------------------------------------------------------------------
  build-and-scan-images:
    name: Build, Scan & Push Images
    runs-on: ubuntu-latest
    needs: tests
    env:
      REGISTRY: ghcr.io
      IMAGE_NAMESPACE: ${{ github.repository }}
      GHCR_TOKEN: ${{ secrets.GHCR_TOKEN }}
    steps:
      - uses: actions/checkout@v4
      - name: Login to GHCR
        if: ${{ env.GHCR_TOKEN != '' }}
        uses: docker/login-action@v3
        with:
          registry: ${{ env.REGISTRY }}
          username: ${{ github.actor }}
          password: ${{ env.GHCR_TOKEN }}

      # Restaurar Caché de Trivy para acelerar escaneo de imagen
      - name: Restore Trivy DB Cache
        uses: actions/cache@v4
        with:
          path: .trivy
          key: trivy-db-${{ runner.os }}-${{ github.run_id }}
          restore-keys: trivy-db-${{ runner.os }}

      - name: Build, scan and push
        run: |
          IMAGE_NS=$(echo "${IMAGE_NAMESPACE}" | tr '[:upper:]' '[:lower:]')
          API_IMG_ID="$REGISTRY/$IMAGE_NS/api:${{ github.run_id }}"
          FRONTEND_IMG_ID="$REGISTRY/$IMAGE_NS/frontend:${{ github.run_id }}"
          SCRAPER_IMG_ID="$REGISTRY/$IMAGE_NS/scraper:${{ github.run_id }}"

          docker build -t $API_IMG_ID -f services/api/Dockerfile services/api
          docker build -t $FRONTEND_IMG_ID -f services/frontend/Dockerfile services/frontend
          docker build -t $SCRAPER_IMG_ID -f services/scraper/Dockerfile services/scraper

          curl -sfL https://raw.githubusercontent.com/aquasecurity/trivy/main/contrib/install.sh | sh -s -- -b /usr/local/bin
          mkdir -p reports
          
          # Descarga optimizada usando caché
          trivy image --download-db-only --cache-dir .trivy

          # Escaneos usando caché
          trivy image --cache-dir .trivy --format json --output reports/trivy-api.json --severity HIGH,CRITICAL --exit-code 1 $API_IMG_ID
          trivy image --cache-dir .trivy --format json --output reports/trivy-frontend.json --severity HIGH,CRITICAL --exit-code 1 $FRONTEND_IMG_ID
          trivy image --cache-dir .trivy --format json --output reports/trivy-scraper.json --severity HIGH,CRITICAL --exit-code 1 $SCRAPER_IMG_ID

          # Generación de reportes HTML (sin romper el build si falla el template)
          (trivy image --cache-dir .trivy --format template --template @contrib/html.tpl --output reports/trivy-api.html $API_IMG_ID || true)
          (trivy image --cache-dir .trivy --format template --template @contrib/html.tpl --output reports/trivy-frontend.html $FRONTEND_IMG_ID || true)
          (trivy image --cache-dir .trivy --format template --template @contrib/html.tpl --output reports/trivy-scraper.html $SCRAPER_IMG_ID || true)
          
          (cd reports && zip -r ../trivy-reports-${{ github.run_id }}.zip . || true)

          docker push $API_IMG_ID
          docker push $FRONTEND_IMG_ID
          docker push $SCRAPER_IMG_ID

      - name: Upload Trivy reports
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: trivy-reports
          path: |
            reports/*.json
            reports/*.html
            trivy-reports-*.zip

  # ------------------------------------------------------------------
  # Job 7: Escaneo Dinámico (DAST)
  # MEJORA: Usa las imágenes reales descargadas (PULL) en vez de reconstruir
  # ------------------------------------------------------------------
  dast:
    name: DAST — OWASP ZAP
    runs-on: ubuntu-latest
    needs: build-and-scan-images
    permissions:
      contents: read
      issues: write
      pull-requests: write
      actions: read
    outputs:
      dast_critical: ${{ steps.set-dast-output.outputs.dast_critical }}
      dast_high: ${{ steps.set-dast-output.outputs.dast_high }}
    env:
      REGISTRY: ghcr.io
      IMAGE_NAMESPACE: ${{ github.repository }}
      IMAGE_TAG: ${{ github.run_id }}
      GHCR_TOKEN: ${{ secrets.GHCR_TOKEN }}
    steps:
      - uses: actions/checkout@v4
      - name: Login to GHCR
        if: ${{ env.GHCR_TOKEN != '' }}
        uses: docker/login-action@v3
        with:
          registry: ${{ env.REGISTRY }}
          username: ${{ github.actor }}
          password: ${{ env.GHCR_TOKEN }}

      # --- ¡NUEVO PASO! CREAR ARCHIVO .ENV TEMPORAL ---
      - name: Create .env file
        run: |
          echo "POSTGRES_USER=postgres" >> .env
          echo "POSTGRES_PASSWORD=postgres" >> .env
          echo "POSTGRES_DB=centinela" >> .env
          echo "DATABASE_URL=postgresql://postgres:postgres@db:5432/centinela" >> .env
          echo "REDIS_HOST=redis" >> .env
          echo "NEWS_API_KEY=dummy_key_for_ci" >> .env
          # Agrega aquí cualquier otra variable que use tu docker-compose
      # -----------------------------------------------

      - name: Run application stack (PULL images)
        run: |
          export IMAGE_NAMESPACE=$(echo "${IMAGE_NAMESPACE}" | tr '[:upper:]' '[:lower:]')
          export IMAGE_TAG=${{ env.IMAGE_TAG }}

          echo "Descargando imágenes verificadas: tag $IMAGE_TAG"
          
          # Intentamos pull, si falla hacemos build (fallback)
          docker compose -f docker-compose.yml pull || echo "Pull falló, intentando build local..." && docker compose -f docker-compose.yml build 

          docker compose -f docker-compose.yml up -d
          sleep 30

      - name: Run ZAP Baseline Scan
        run: |
          mkdir -p reports
          FRONTEND_CID=$(docker compose ps -q frontend)
          if [ -z "$FRONTEND_CID" ]; then echo "ERROR: no se encontró 'frontend'"; exit 1; fi
          NETWORK_NAME=$(docker inspect --format '{{range $k,$v := .NetworkSettings.Networks}}{{$k}} {{end}}' $FRONTEND_CID | awk '{print $1}')

          # Esperar disponibilidad real
          docker run --rm --network "$NETWORK_NAME" busybox sh -c 'until wget -qO- http://frontend:80 >/dev/null 2>&1; do echo waiting...; sleep 5; done'

          docker run --rm -u 0 --network "$NETWORK_NAME" --name zap_scanner \
            -v "$(pwd)/reports":/zap/wrk -w /zap/wrk \
            ghcr.io/zaproxy/zaproxy zap-baseline.py \
              -t http://frontend:80 \
              -r report_dast_zap.html \
              -J report_dast_zap.json || true

      - name: Upload ZAP report
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: reporte-dast-zap
          path: reports/report_dast_zap.*

      - name: Parse ZAP JSON & set outputs
        id: set-dast-output
        if: always()
        run: |
          set -euo pipefail || true
          if ! command -v jq >/dev/null 2>&1; then sudo apt-get update -y && sudo apt-get install -y jq || true; fi
          if [ ! -f reports/report_dast_zap.json ]; then
             echo "dast_critical=0" >> $GITHUB_OUTPUT
             echo "dast_high=0" >> $GITHUB_OUTPUT
             exit 0
          fi
          critical=$(jq '[.site[]?.alerts[]? | select(.risk=="High" or .risk=="Critical")] | length' reports/report_dast_zap.json || echo 0)
          high=$(jq '[.site[]?.alerts[]? | select(.risk=="High")] | length' reports/report_dast_zap.json || echo 0)
          echo "dast_critical=$critical" >> $GITHUB_OUTPUT
          echo "dast_high=$high" >> $GITHUB_OUTPUT

      - name: Stop application stack
        if: always()
        run: docker compose -f docker-compose.yml down --volumes --remove-orphans

  # ------------------------------------------------------------------
  # Job 8: Publicar Imágenes (Latest)
  # ------------------------------------------------------------------
  publish-and-deploy:
    name: Publish ':latest' tags
    runs-on: ubuntu-latest
    needs: dast
    permissions:
      contents: read
      packages: write
    if: github.event_name == 'push' && github.ref == 'refs/heads/main'
    env:
      REGISTRY: ghcr.io
      IMAGE_NAMESPACE: ${{ github.repository }}
      GHCR_TOKEN: ${{ secrets.GHCR_TOKEN }}
    steps:
      - name: Login GHCR
        uses: docker/login-action@v3
        with:
          registry: ${{ env.REGISTRY }}
          username: ${{ github.actor }}
          password: ${{ env.GHCR_TOKEN }}
      - run: |
          IMAGE_NS=$(echo "${IMAGE_NAMESPACE}" | tr '[:upper:]' '[:lower:]')
          for SERVICE in api frontend scraper; do
            docker pull $REGISTRY/$IMAGE_NS/$SERVICE:${{ github.run_id }}
            docker tag  $REGISTRY/$IMAGE_NS/$SERVICE:${{ github.run_id }} $REGISTRY/$IMAGE_NS/$SERVICE:latest
            docker push $REGISTRY/$IMAGE_NS/$SERVICE:latest
          done

  # ------------------------------------------------------------------
  # Job 9: Limpieza
  # ------------------------------------------------------------------
  cleanup:
    name: Cleanup
    runs-on: ubuntu-latest
    needs: publish-and-deploy
    if: always()
    steps:
      - run: docker image prune -af || true

  # ------------------------------------------------------------------
  # Job 10: Despliegue a Producción (SIMULADO)
  # ------------------------------------------------------------------
  deploy-to-production:
    name: "Deploy to Production (SIMULATED)" 
    runs-on: ubuntu-latest
    needs: publish-and-deploy
    # MEJORA: Agregar entorno para aprobación manual en UI de GitHub (Opcional)
    environment: 
      name: production
      url: http://centinela-demo.uniminuto.edu
    if: github.event_name == 'push' && github.ref == 'refs/heads/main'
    env:
      SIM_DEPLOY_USER: "ubuntu"
      SIM_DEPLOY_HOST: "123.45.67.89"
    steps:
      - uses: actions/checkout@v4
      - name: Simulación de Despliegue
        run: |
          echo "Simulando conexión SSH a $SIM_DEPLOY_HOST..."
          echo "Ejecutando: docker compose pull && docker compose up -d"
          echo "¡Despliegue simulado exitoso!"