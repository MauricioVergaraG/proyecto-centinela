# ------------------------------------------------------------------
# Nombre del Workflow
# ------------------------------------------------------------------
name: CI/CD Full - Centinela (DevSecOps)

# ------------------------------------------------------------------
# Disparadores (Triggers)
# ------------------------------------------------------------------
on:
  push:
    branches: [ main ]
  pull_request:
    branches: [ main ]
  workflow_dispatch: {}

# ------------------------------------------------------------------
# Trabajos (Jobs)
# ------------------------------------------------------------------
jobs:

  # ------------------------------------------------------------------
  # Job 1: Preparar Caché
  # ------------------------------------------------------------------
  setup-cache:
    name: Prepare & Cache (pip / npm)
    runs-on: ubuntu-latest
    steps:
      - name: Checkout
        uses: actions/checkout@v4
      - name: Cache pip packages
        id: cache-pip
        uses: actions/cache@v4
        with:
          path: ~/.cache/pip
          key: pip-${{ hashFiles('**/services/**/requirements.txt') }}-${{ runner.os }}
          restore-keys: |
            pip-${{ runner.os }}
      - name: Cache node modules
        id: cache-node
        uses: actions/cache@v4
        with:
          path: |
            services/frontend/node_modules
            ~/.npm
          key: node-${{ hashFiles('services/frontend/**/package-lock.json') }}-${{ runner.os }}
          restore-keys: |
            node-${{ runner.os }}

  # ------------------------------------------------------------------
  # Job 2: Escaneo Estático (SAST) y Calidad de Código
  # ------------------------------------------------------------------
  lint-format-sast:
    name: Lint / Format / SAST
    runs-on: ubuntu-latest
    needs: setup-cache
    steps:
      - uses: actions/checkout@v4
      - uses: actions/setup-python@v4
        with:
          python-version: '3.11'
      - run: |
          python -m pip install --upgrade pip
          pip install black flake8 bandit semgrep
      - run: black --check services
      - run: flake8 services --ignore=E501
      - run: bandit -r services/api -lll
      - run: semgrep --config ./.semgrep/basic-rules.yml

  # ------------------------------------------------------------------
  # Job 3: Escaneo de Dependencias (SCA)
  # ------------------------------------------------------------------
  dependency-scan:
    name: Dependency & Filesystem Scan (Trivy SBOM)
    runs-on: ubuntu-latest
    needs: lint-format-sast
    steps:
      - uses: actions/checkout@v4
      - run: curl -sfL https://raw.githubusercontent.com/aquasecurity/trivy/main/contrib/install.sh | sh -s -- -b /usr/local/bin
      - run: trivy fs --severity HIGH,CRITICAL --exit-code 1 --no-progress .

  # ------------------------------------------------------------------
  # Job 4: Escaneo de Infraestructura como Código (IaC)
  # ------------------------------------------------------------------
  iac-scan:
    name: IaC Scan (Checkov)
    runs-on: ubuntu-latest
    needs: setup-cache
    steps:
        - name: Checkout
          uses: actions/checkout@v4
        - name: Run Checkov scan
          uses: bridgecrewio/checkov-action@v12
          with:
            directory: ./terraform
            framework: terraform
            output_format: cli
            soft_fail: true

 # ------------------------------------------------------------------
  # Job 5: Pruebas Unitarias y de Integración
  # ------------------------------------------------------------------
  tests:
    name: Unit & Smoke Tests
    runs-on: ubuntu-latest
    needs: dependency-scan
    steps:
      - uses: actions/checkout@v4
      - uses: actions/setup-python@v4
        with:
          python-version: '3.11'

      # --- ¡AQUÍ ESTÁ LA CORRECCIÓN DE PYTHONPATH! ---
      - name: Instalar y Correr Pruebas de Python
        run: |
          pip install -r services/api/requirements.txt
          pip install pytest
          # --- ¡ARREGLO! ---
          # Ya no necesitamos 'export PYTHONPATH'.
          # Simplemente corremos 'pytest' y dejamos que descubra los tests.
          pytest -q

      - uses: actions/setup-node@v4
        with:
          node-version: '20'
      - name: Construir Frontend (smoke test)
        run: |
          cd services/frontend
          if [ -f "index.html" ]; then
            echo "index.html encontrado."
          else
            echo "Error: index.html no encontrado."
            exit 1
          fi

  # ------------------------------------------------------------------
  # Job 6: Construcción y Escaneo de Imágenes Docker
  # ------------------------------------------------------------------
  build-and-scan-images:
    name: Build, Scan & Push Versioned Images
    runs-on: ubuntu-latest
    needs: tests
    env:
      REGISTRY: ghcr.io
      IMAGE_NAMESPACE: ${{ github.repository }}
      GHCR_TOKEN: ${{ secrets.GHCR_TOKEN }}
    steps:
      - uses: actions/checkout@v4
      - name: Login to GHCR
        if: ${{ env.GHCR_TOKEN != '' }}
        uses: docker/login-action@v3
        with:
          registry: ${{ env.REGISTRY }}
          username: ${{ github.actor }}
          password: ${{ env.GHCR_TOKEN }}

      - name: Build, scan and push images
        run: |
          IMAGE_NS=$(echo "${IMAGE_NAMESPACE}" | tr '[:upper:]' '[:lower:]')
          API_IMG_ID="$REGISTRY/$IMAGE_NS/api:${{ github.run_id }}"
          FRONTEND_IMG_ID="$REGISTRY/$IMAGE_NS/frontend:${{ github.run_id }}"
          SCRAPER_IMG_ID="$REGISTRY/$IMAGE_NS/scraper:${{ github.run_id }}"

          docker build -t $API_IMG_ID -f services/api/Dockerfile services/api
          docker build -t $FRONTEND_IMG_ID -f services/frontend/Dockerfile services/frontend
          docker build -t $SCRAPER_IMG_ID -f services/scraper/Dockerfile services/scraper

          curl -sfL https://raw.githubusercontent.com/aquasecurity/trivy/main/contrib/install.sh | sh -s -- -b /usr/local/bin
          mkdir -p reports
          trivy --download-db-only || true

          trivy image --format json --output reports/trivy-api.json --severity HIGH,CRITICAL --exit-code 1 $API_IMG_ID
          trivy image --format json --output reports/trivy-frontend.json --severity HIGH,CRITICAL --exit-code 1 $FRONTEND_IMG_ID
          trivy image --format json --output reports/trivy-scraper.json --severity HIGH,CRITICAL --exit-code 1 $SCRAPER_IMG_ID

          (trivy image --format template --template @contrib/html.tpl --output reports/trivy-api.html $API_IMG_ID || true)
          (trivy image --format template --template @contrib/html.tpl --output reports/trivy-frontend.html $FRONTEND_IMG_ID || true)
          (trivy image --format template --template @contrib/html.tpl --output reports/trivy-scraper.html $SCRAPER_IMG_ID || true)
          (cd reports && zip -r ../trivy-reports-${{ github.run_id }}.zip . || true)
          (cd - >/dev/null || true)

          docker push $API_IMG_ID
          docker push $FRONTEND_IMG_ID
          docker push $SCRAPER_IMG_ID

      - name: Upload Trivy reports
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: trivy-reports
          path: |
            reports/*.json
            reports/*.html
            trivy-reports-*.zip
          if-no-files-found: ignore

  # ------------------------------------------------------------------
  # Job 7: Escaneo Dinámico (DAST)
  # ------------------------------------------------------------------
  dast:
    name: DAST — OWASP ZAP
    runs-on: ubuntu-latest
    needs: build-and-scan-images
    permissions:
      contents: read
      issues: write
      pull-requests: write
      actions: read
    outputs:
      dast_critical: ${{ steps.set-dast-output.outputs.dast_critical }}
      dast_high: ${{ steps.set-dast-output.outputs.dast_high }}
      dast_total: ${{ steps.set-dast-output.outputs.dast_total }}
    if: always()
    env:
      REGISTRY: ghcr.io
      IMAGE_NAMESPACE: ${{ github.repository }}
      IMAGE_TAG: ${{ github.run_id }}
      GHCR_TOKEN: ${{ secrets.GHCR_TOKEN }}
    steps:
      - uses: actions/checkout@v4
      - name: Login to GHCR
        if: ${{ env.GHCR_TOKEN != '' }}
        uses: docker/login-action@v3
        with:
          registry: ${{ env.REGISTRY }}
          username: ${{ github.actor }}
          password: ${{ env.GHCR_TOKEN }}

      - name: Run application stack
        run: |
          export IMAGE_NAMESPACE=$(echo "${IMAGE_NAMESPACE}" | tr '[:upper:]' '[:lower:]')
          export IMAGE_TAG=${{ env.IMAGE_TAG }}

          echo "Building service images (frontend, api, scraper)"
          DOCKER_BUILDKIT=1 docker compose -f docker-compose.yml build frontend api scraper --no-cache 2>&1 | tee build-compose.log || BUILD_FAILED=1

          if [ ! -z "${BUILD_FAILED}" ]; then
            echo "ERROR: docker compose build failed..."
            exit 1
          fi

          docker compose -f docker-compose.yml pull || true
          docker compose -f docker-compose.yml up -d && sleep 30

      - name: Run ZAP Baseline Scan
        run: |
          mkdir -p reports
          FRONTEND_CID=$(docker compose ps -q frontend)
          if [ -z "$FRONTEND_CID" ]; then echo "ERROR: no se encontró 'frontend'"; exit 1; fi
          NETWORK_NAME=$(docker inspect --format '{{range $k,$v := .NetworkSettings.Networks}}{{$k}} {{end}}' $FRONTEND_CID | awk '{print $1}')

          REACHABLE=0
          for i in $(seq 1 12); do
            echo "Intento $i/12..."
            docker run --rm --network "$NETWORK_NAME" busybox wget -qO- http://frontend:80 >/dev/null 2>&1 && { REACHABLE=1; break; } || sleep 5
          done

          docker run --rm -u 0 --network "$NETWORK_NAME" --name zap_scanner \
            -v "$(pwd)/reports":/zap/wrk -w /zap/wrk \
            ghcr.io/zaproxy/zaproxy zap-baseline.py \
              -t http://frontend:80 \
              -r report_dast_zap.html \
              -J report_dast_zap.json || true

      - name: Upload ZAP report
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: reporte-dast-zap
          path: reports/report_dast_zap.html
          if-no-files-found: ignore

      - name: Upload ZAP JSON report
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: reporte-dast-zap-json
          path: reports/report_dast_zap.json
          if-no-files-found: ignore

      - name: Collect frontend headers (debug)
        if: always()
        run: |
          mkdir -p reports || true
          FRONTEND_CID=$(docker compose ps -q frontend)
          if [ -z "$FRONTEND_CID" ]; then
            echo "WARNING: frontend container missing"
          else
            NETWORK_NAME=$(docker inspect --format '{{range $k,$v := .NetworkSettings.Networks}}{{$k}} {{end}}' $FRONTEND_CID | awk '{print $1}')
            docker run --rm --network "$NETWORK_NAME" curlimages/curl:8.5.0 -sI http://frontend:80 > reports/frontend-headers.txt || true
          fi

      - name: Upload frontend headers (debug)
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: frontend-headers
          path: reports/frontend-headers.txt
          if-no-files-found: ignore

      - name: Parse ZAP JSON & set outputs
        id: set-dast-output
        if: always()
        run: |
          set -euo pipefail || true
          if ! command -v jq >/dev/null 2>&1; then sudo apt-get update -y && sudo apt-get install -y jq || true; fi
          if [ ! -f reports/report_dast_zap.json ]; then
             echo "dast_critical=0" >> $GITHUB_OUTPUT
             echo "dast_high=0" >> $GITHUB_OUTPUT
             exit 0
          fi
          critical=$(jq '[.site[]?.alerts[]? | select(.risk=="High" or .risk=="Critical")] | length' reports/report_dast_zap.json || echo 0)
          high=$(jq '[.site[]?.alerts[]? | select(.risk=="High")] | length' reports/report_dast_zap.json || echo 0)
          echo "dast_critical=$critical" >> $GITHUB_OUTPUT
          echo "dast_high=$high" >> $GITHUB_OUTPUT

      - name: Create issue or comment if HIGH/CRITICAL findings
        if: always()
        continue-on-error: true
        uses: actions/github-script@v6
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const critical = parseInt(process.env.DAST_CRITICAL || '0');
            const high = parseInt(process.env.DAST_HIGH || '0');
            if (critical > 0 || high > 0) {
              const body = `DAST scan detected issues...`;
            }
        env:
          DAST_CRITICAL: ${{ steps.set-dast-output.outputs.dast_critical }}
          DAST_HIGH: ${{ steps.set-dast-output.outputs.dast_high }}

      - name: Fail job if critical/high findings
        if: always()
        run: |
          CRITICAL=${{ steps.set-dast-output.outputs.dast_critical }}
          HIGH=${{ steps.set-dast-output.outputs.dast_high }}
          if [ "$CRITICAL" -gt 0 ] || [ "$HIGH" -gt 0 ]; then
            echo "::error:: DAST found $CRITICAL critical and $HIGH high vulnerabilities. Failing build."
            exit 1
          else
            echo "DAST scan passed."
          fi

      - name: Stop application stack
        if: always()
        run: docker compose -f docker-compose.yml down --volumes --remove-orphans

  # ------------------------------------------------------------------
  # Job 8: Publicar Imágenes
  # ------------------------------------------------------------------
  publish-and-deploy:
    name: Publish ':latest' tags
    runs-on: ubuntu-latest
    needs: dast
    permissions:
      contents: read
      packages: write
    if: github.event_name == 'push' && github.ref == 'refs/heads/main'
    env:
      REGISTRY: ghcr.io
      IMAGE_NAMESPACE: ${{ github.repository }}
      GHCR_TOKEN: ${{ secrets.GHCR_TOKEN }}
    steps:
      - name: Login GHCR
        if: ${{ env.GHCR_TOKEN != '' }}
        uses: docker/login-action@v3
        with:
          registry: ${{ env.REGISTRY }}
          username: ${{ github.actor }}
          password: ${{ env.GHCR_TOKEN }}
      - run: | # Retiqueta API
          IMAGE_NS=$(echo "${IMAGE_NAMESPACE}" | tr '[:upper:]' '[:lower:]')
          docker pull $REGISTRY/$IMAGE_NS/api:${{ github.run_id }}
          docker tag  $REGISTRY/$IMAGE_NS/api:${{ github.run_id }} $REGISTRY/$IMAGE_NS/api:latest
          docker push $REGISTRY/$IMAGE_NS/api:latest
      - run: | # Retiqueta Frontend
          IMAGE_NS=$(echo "${IMAGE_NAMESPACE}" | tr '[:upper:]' '[:lower:]')
          docker pull $REGISTRY/$IMAGE_NS/frontend:${{ github.run_id }}
          docker tag  $REGISTRY/$IMAGE_NS/frontend:${{ github.run_id }} $REGISTRY/$IMAGE_NS/frontend:latest
          docker push $REGISTRY/$IMAGE_NS/frontend:latest
      - run: | # Retiqueta Scraper
          IMAGE_NS=$(echo "${IMAGE_NAMESPACE}" | tr '[:upper:]' '[:lower:]')
          docker pull $REGISTRY/$IMAGE_NS/scraper:${{ github.run_id }}
          docker tag  $REGISTRY/$IMAGE_NS/scraper:${{ github.run_id }} $REGISTRY/$IMAGE_NS/scraper:latest
          docker push $REGISTRY/$IMAGE_NS/scraper:latest

  # ------------------------------------------------------------------
  # Job 9: Limpieza
  # ------------------------------------------------------------------
  cleanup:
    name: Cleanup
    runs-on: ubuntu-latest
    needs: publish-and-deploy
    if: always()
    steps:
      - run: docker image prune -af || true

  # ------------------------------------------------------------------
  # Job 10: Despliegue a Producción (CD)
  # ------------------------------------------------------------------
  deploy-to-production:
    name: "Deploy to Production"
    runs-on: ubuntu-latest
    needs: publish-and-deploy
    if: github.event_name == 'push' && github.ref == 'refs/heads/main'
    permissions:
      contents: read
      packages: write
    env:
      REGISTRY: ghcr.io
    steps:
      - name: 1. Checkout (para obtener el docker-compose.yml)
        uses: actions/checkout@v4
      - name: 2. Configurar clave SSH
        uses: shimataro/ssh-key-action@v2
        with:
          key: ${{ secrets.DEPLOY_KEY }}
          known_hosts: 'placeholder'
      - name: 3. Añadir IP del host a known_hosts
        run: |
          ssh-keyscan -H ${{ secrets.DEPLOY_HOST }} >> ~/.ssh/known_hosts
      - name: 4. Desplegar en el Servidor
        run: |
          REMOTE_HOST="${{ secrets.DEPLOY_USER }}@${{ secrets.DEPLOY_HOST }}"
          scp -o StrictHostKeyChecking=no docker-compose.yml $REMOTE_HOST:/home/ubuntu/centinela/docker-compose.yml
          ssh -o StrictHostKeyChecking=no $REMOTE_HOST << 'EOF'
            cd /home/ubuntu/centinela
            echo "${{ secrets.GHCR_TOKEN }}" | docker login ghcr.io -u ${{ github.actor }} --password-stdin
            docker compose pull
            docker compose up -d
            docker image prune -af
          EOF
